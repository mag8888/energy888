const http = require('http');
const url = require('url');
const { Server } = require('socket.io');

const PORT = process.env.PORT || 4000;
const HOST = process.env.NODE_ENV === 'production' ? '0.0.0.0' : 'localhost';

// –•—Ä–∞–Ω–∏–ª–∏—â–µ —Ç–æ–∫–µ–Ω–æ–≤ –∏ –∫–æ–º–Ω–∞—Ç
const tokens = new Map();
const rooms = new Map();

// CORS headers
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Origin, X-Requested-With, Content-Type, Accept, Authorization',
  'Content-Type': 'application/json'
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ JSON –æ—Ç–≤–µ—Ç–∞
function sendJSON(res, statusCode, data) {
  res.writeHead(statusCode, corsHeaders);
  res.end(JSON.stringify(data));
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ POST –¥–∞–Ω–Ω—ã—Ö
function parsePostData(req, callback) {
  let body = '';
  req.on('data', chunk => {
    body += chunk.toString();
  });
  req.on('end', () => {
    try {
      const data = JSON.parse(body);
      callback(data);
    } catch (error) {
      callback(null);
    }
  });
}

// –°–æ–∑–¥–∞–Ω–∏–µ HTTP —Å–µ—Ä–≤–µ—Ä–∞
const server = http.createServer((req, res) => {
  const parsedUrl = url.parse(req.url, true);
  const path = parsedUrl.pathname;
  const method = req.method;

  console.log(`${method} ${path}`);

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ CORS preflight
  if (method === 'OPTIONS') {
    res.writeHead(200, corsHeaders);
    res.end();
    return;
  }

  // –ú–∞—Ä—à—Ä—É—Ç—ã
  if (path === '/' && method === 'GET') {
    sendJSON(res, 200, {
      ok: true,
      message: 'Energy888 Socket Server is running',
      environment: process.env.NODE_ENV || 'development',
      port: PORT,
      host: HOST,
      timestamp: new Date().toISOString(),
      endpoints: {
        health: '/health',
        newToken: '/tg/new-token',
        poll: '/tg/poll',
        authorize: '/tg/authorize'
      }
    });
  }
  else if (path === '/health' && method === 'GET') {
    sendJSON(res, 200, {
      ok: true,
      status: 'healthy',
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      tokens: tokens.size,
      rooms: rooms.size,
      connectedClients: io.engine.clientsCount
    });
  }
  else if (path === '/tg/new-token' && method === 'GET') {
    try {
      const token = `t_${Date.now().toString(36)}_${Math.random().toString(36).slice(2,8)}`;
      
      tokens.set(token, {
        createdAt: Date.now(),
        authorized: false
      });
      
      console.log('üîë –°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π —Ç–æ–∫–µ–Ω:', token);
      
      sendJSON(res, 200, {
        ok: true,
        token,
        expiresIn: 300000
      });
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–æ–∫–µ–Ω–∞:', error);
      sendJSON(res, 500, { ok: false, error: 'Failed to create token' });
    }
  }
  else if (path === '/tg/poll' && method === 'GET') {
    try {
      const { token } = parsedUrl.query;
      
      if (!token) {
        sendJSON(res, 400, { ok: false, error: 'Token required' });
        return;
      }
      
      const tokenData = tokens.get(token);
      
      if (!tokenData) {
        sendJSON(res, 404, { ok: false, error: 'Token not found' });
        return;
      }
      
      if (Date.now() - tokenData.createdAt > 300000) {
        tokens.delete(token);
        sendJSON(res, 410, { ok: false, error: 'Token expired' });
        return;
      }
      
      sendJSON(res, 200, {
        ok: true,
        authorized: tokenData.authorized,
        user: tokenData.user || null
      });
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–æ–∫–µ–Ω–∞:', error);
      sendJSON(res, 500, { ok: false, error: 'Failed to check token' });
    }
  }
  else if (path === '/tg/authorize' && method === 'POST') {
    parsePostData(req, (data) => {
      try {
        if (!data) {
          sendJSON(res, 400, { ok: false, error: 'Invalid JSON' });
          return;
        }

        const { token, id, username, first_name, last_name, photo_url } = data;
        
        console.log('üîê –ü–æ–ø—ã—Ç–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏:', { token, id, username });
        
        if (!token) {
          sendJSON(res, 400, { ok: false, error: 'Token required' });
          return;
        }
        
        const tokenData = tokens.get(token);
        
        if (!tokenData) {
          sendJSON(res, 404, { ok: false, error: 'Token not found' });
          return;
        }
        
        if (Date.now() - tokenData.createdAt > 300000) {
          tokens.delete(token);
          sendJSON(res, 410, { ok: false, error: 'Token expired' });
          return;
        }
        
        const userData = {
          id: `tg_${id}`,
          username: username || `user_${id}`,
          tgId: id,
          firstName: first_name,
          lastName: last_name,
          photoUrl: photo_url
        };
        
        tokenData.authorized = true;
        tokenData.user = userData;
        
        console.log('‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω:', userData);
        
        sendJSON(res, 200, {
          ok: true,
          authorized: true,
          user: userData
        });
      } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏:', error);
        sendJSON(res, 500, { ok: false, error: 'Authorization failed' });
      }
    });
  }
  else {
    sendJSON(res, 404, { ok: false, error: 'Not found' });
  }
});

// –°–æ–∑–¥–∞–Ω–∏–µ Socket.IO —Å–µ—Ä–≤–µ—Ä–∞
const io = new Server(server, {
  cors: {
    origin: [
      "https://money8888-production.up.railway.app",
      "http://localhost:3000",
      "https://money8888-production.up.railway.app"
    ],
    methods: ["GET", "POST"],
    credentials: true
  }
});

// Socket.IO –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
io.on('connection', (socket) => {
  console.log('üîå –ö–ª–∏–µ–Ω—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω:', socket.id);
  
  // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –∫–æ–º–Ω–∞—Ç
  socket.on('get-rooms', () => {
    const roomsList = Array.from(rooms.values()).map(room => ({
      id: room.id,
      name: room.name,
      players: room.players.length,
      maxPlayers: room.maxPlayers,
      status: room.status,
      timing: room.timing,
      createdAt: room.createdAt
    }));
    
    socket.emit('rooms-list', roomsList);
    console.log('üìã –û—Ç–ø—Ä–∞–≤–ª–µ–Ω —Å–ø–∏—Å–æ–∫ –∫–æ–º–Ω–∞—Ç:', roomsList.length);
  });
  
  // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã
  socket.on('create-room', (roomData) => {
    try {
      const roomId = `room_${Date.now()}_${Math.random().toString(36).slice(2,8)}`;
      const room = {
        id: roomId,
        name: roomData.name || `–ö–æ–º–Ω–∞—Ç–∞ ${rooms.size + 1}`,
        players: [],
        maxPlayers: roomData.maxPlayers || 4,
        status: 'waiting',
        timing: roomData.timing || 120, // 2 –º–∏–Ω—É—Ç—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        createdAt: Date.now(),
        createdBy: socket.id
      };
      
      rooms.set(roomId, room);
      
      // –ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ–º —Å–æ–∑–¥–∞—Ç–µ–ª—è –∫ –∫–æ–º–Ω–∞—Ç–µ
      socket.join(roomId);
      room.players.push({
        id: socket.id,
        name: roomData.playerName || '–ò–≥—Ä–æ–∫',
        email: roomData.playerEmail || 'player@example.com',
        isReady: false
      });
      
      console.log('üè† –°–æ–∑–¥–∞–Ω–∞ –∫–æ–º–Ω–∞—Ç–∞:', roomId, room.name);
      
      // –£–≤–µ–¥–æ–º–ª—è–µ–º –≤—Å–µ—Ö –æ –Ω–æ–≤–æ–π –∫–æ–º–Ω–∞—Ç–µ
      io.emit('room-created', {
        id: room.id,
        name: room.name,
        players: room.players.length,
        maxPlayers: room.maxPlayers,
        status: room.status,
        timing: room.timing,
        createdAt: room.createdAt
      });
      
      socket.emit('room-created-success', room);
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–º–Ω–∞—Ç—ã:', error);
      socket.emit('room-created-error', { error: 'Failed to create room' });
    }
  });
  
  // –ü—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫ –∫–æ–º–Ω–∞—Ç–µ
  socket.on('join-room', (data) => {
    try {
      const { roomId, playerName, playerEmail } = data;
      const room = rooms.get(roomId);
      
      if (!room) {
        socket.emit('join-room-error', { error: 'Room not found' });
        return;
      }
      
      if (room.players.length >= room.maxPlayers) {
        socket.emit('join-room-error', { error: 'Room is full' });
        return;
      }
      
      if (room.status !== 'waiting') {
        socket.emit('join-room-error', { error: 'Room is not available' });
        return;
      }
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –ª–∏ —É–∂–µ —ç—Ç–æ—Ç –∏–≥—Ä–æ–∫
      const existingPlayer = room.players.find(p => p.id === socket.id);
      if (existingPlayer) {
        // –ò–≥—Ä–æ–∫ —É–∂–µ –≤ –∫–æ–º–Ω–∞—Ç–µ, –ø—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
        socket.emit('room-joined', {
          id: room.id,
          name: room.name,
          maxPlayers: room.maxPlayers,
          currentPlayers: room.players.length,
          turnTime: room.timing,
          status: room.status,
          players: room.players
        });
        return;
      }
      
      // –ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ–º –∫ –∫–æ–º–Ω–∞—Ç–µ
      socket.join(roomId);
      room.players.push({
        id: socket.id,
        name: playerName || '–ò–≥—Ä–æ–∫',
        email: playerEmail || 'player@example.com',
        isReady: false
      });
      
      console.log('üë§ –ò–≥—Ä–æ–∫ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ:', roomId, playerName);
      
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–ª–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–º–Ω–∞—Ç–µ
      socket.emit('room-joined', {
        id: room.id,
        name: room.name,
        maxPlayers: room.maxPlayers,
        currentPlayers: room.players.length,
        turnTime: room.timing,
        status: room.status,
        players: room.players
      });
      
      // –£–≤–µ–¥–æ–º–ª—è–µ–º –≤—Å–µ—Ö –≤ –∫–æ–º–Ω–∞—Ç–µ
      io.to(roomId).emit('player-joined', {
        playerId: socket.id,
        playerName: playerName || '–ò–≥—Ä–æ–∫',
        players: room.players
      });
      
      // –£–≤–µ–¥–æ–º–ª—è–µ–º –≤—Å–µ—Ö –æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –∫–æ–º–Ω–∞—Ç
      io.emit('rooms-updated');
      
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∫ –∫–æ–º–Ω–∞—Ç–µ:', error);
      socket.emit('join-room-error', { error: 'Failed to join room' });
    }
  });
  
  // –ü–æ–∫–∏–¥–∞–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã
  socket.on('leave-room', (data) => {
    try {
      const { roomId } = data;
      const room = rooms.get(roomId);
      
      if (!room) {
        return;
      }
      
      // –£–¥–∞–ª—è–µ–º –∏–≥—Ä–æ–∫–∞ –∏–∑ –∫–æ–º–Ω–∞—Ç—ã
      const playerIndex = room.players.findIndex(p => p.id === socket.id);
      if (playerIndex !== -1) {
        room.players.splice(playerIndex, 1);
        socket.leave(roomId);
        
        console.log('üë§ –ò–≥—Ä–æ–∫ –ø–æ–∫–∏–Ω—É–ª –∫–æ–º–Ω–∞—Ç—É:', roomId);
        
        // –ï—Å–ª–∏ –∫–æ–º–Ω–∞—Ç–∞ –ø—É—Å—Ç–∞—è, —É–¥–∞–ª—è–µ–º –µ—ë
        if (room.players.length === 0) {
          rooms.delete(roomId);
          console.log('üóëÔ∏è –ö–æ–º–Ω–∞—Ç–∞ —É–¥–∞–ª–µ–Ω–∞ (–ø—É—Å—Ç–∞—è):', roomId);
        } else {
          // –£–≤–µ–¥–æ–º–ª—è–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –∏–≥—Ä–æ–∫–æ–≤
          io.to(roomId).emit('room-updated', {
            id: room.id,
            name: room.name,
            maxPlayers: room.maxPlayers,
            currentPlayers: room.players.length,
            turnTime: room.timing,
            status: room.status,
            players: room.players
          });
        }
        
        // –£–≤–µ–¥–æ–º–ª—è–µ–º –≤—Å–µ—Ö –æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –∫–æ–º–Ω–∞—Ç
        io.emit('rooms-updated');
      }
      
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–∫–∏–¥–∞–Ω–∏—è –∫–æ–º–Ω–∞—Ç—ã:', error);
    }
  });
  
  // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ (–ø—Ä–æ—Ñ–µ—Å—Å–∏—è –∏ –º–µ—á—Ç–∞)
  socket.on('player-setup', (data) => {
    try {
      const { roomId, profession, dream } = data;
      const room = rooms.get(roomId);
      
      if (!room) {
        return;
      }
      
      const player = room.players.find(p => p.id === socket.id);
      if (player) {
        player.profession = profession;
        player.dream = dream;
        player.isReady = true;
        
        console.log('üë§ –ò–≥—Ä–æ–∫ –Ω–∞—Å—Ç—Ä–æ–∏–ª –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:', roomId, player.name, profession, dream);
        
        // –£–≤–µ–¥–æ–º–ª—è–µ–º –≤—Å–µ—Ö –≤ –∫–æ–º–Ω–∞—Ç–µ
        io.to(roomId).emit('room-updated', {
          id: room.id,
          name: room.name,
          maxPlayers: room.maxPlayers,
          currentPlayers: room.players.length,
          turnTime: room.timing,
          status: room.status,
          players: room.players
        });
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤—Å–µ –ª–∏ –≥–æ—Ç–æ–≤—ã –¥–ª—è –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã
        const allReady = room.players.length >= 2 && room.players.every(p => p.isReady && p.profession && p.dream);
        if (allReady && room.status === 'waiting') {
          room.status = 'playing';
          console.log('üéÆ –ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å –≤ –∫–æ–º–Ω–∞—Ç–µ:', roomId);
          
          io.to(roomId).emit('game-started', {
            id: room.id,
            name: room.name,
            maxPlayers: room.maxPlayers,
            currentPlayers: room.players.length,
            turnTime: room.timing,
            status: room.status,
            players: room.players
          });
        }
      }
      
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:', error);
    }
  });

  // –ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∏–≥—Ä–æ–∫–∞
  socket.on('player-ready', (data) => {
    try {
      const { roomId } = data;
      const room = rooms.get(roomId);
      
      if (!room) {
        return;
      }
      
      const player = room.players.find(p => p.id === socket.id);
      if (player) {
        player.isReady = !player.isReady;
        
        console.log('üë§ –ò–≥—Ä–æ–∫ –∏–∑–º–µ–Ω–∏–ª –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å:', roomId, player.name, player.isReady);
        
        // –£–≤–µ–¥–æ–º–ª—è–µ–º –≤—Å–µ—Ö –≤ –∫–æ–º–Ω–∞—Ç–µ
        io.to(roomId).emit('room-updated', {
          id: room.id,
          name: room.name,
          maxPlayers: room.maxPlayers,
          currentPlayers: room.players.length,
          turnTime: room.timing,
          status: room.status,
          players: room.players
        });
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤—Å–µ –ª–∏ –≥–æ—Ç–æ–≤—ã –¥–ª—è –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã
        const allReady = room.players.length >= 2 && room.players.every(p => p.isReady);
        if (allReady && room.status === 'waiting') {
          room.status = 'playing';
          console.log('üéÆ –ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å –≤ –∫–æ–º–Ω–∞—Ç–µ:', roomId);
          
          io.to(roomId).emit('game-started', {
            id: room.id,
            name: room.name,
            maxPlayers: room.maxPlayers,
            currentPlayers: room.players.length,
            turnTime: room.timing,
            status: room.status,
            players: room.players
          });
        }
      }
      
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏:', error);
    }
  });
  
  // –û—Ç–∫–ª—é—á–µ–Ω–∏–µ
  socket.on('disconnect', () => {
    console.log('üîå –ö–ª–∏–µ–Ω—Ç –æ—Ç–∫–ª—é—á–µ–Ω:', socket.id);
    
    // –£–¥–∞–ª—è–µ–º –∏–≥—Ä–æ–∫–∞ –∏–∑ –≤—Å–µ—Ö –∫–æ–º–Ω–∞—Ç
    for (const [roomId, room] of rooms.entries()) {
      const playerIndex = room.players.findIndex(p => p.id === socket.id);
      if (playerIndex !== -1) {
        room.players.splice(playerIndex, 1);
        
        // –ï—Å–ª–∏ –∫–æ–º–Ω–∞—Ç–∞ –ø—É—Å—Ç–∞—è, —É–¥–∞–ª—è–µ–º –µ—ë
        if (room.players.length === 0) {
          rooms.delete(roomId);
          console.log('üóëÔ∏è –ö–æ–º–Ω–∞—Ç–∞ —É–¥–∞–ª–µ–Ω–∞ (–ø—É—Å—Ç–∞—è):', roomId);
        } else {
          // –£–≤–µ–¥–æ–º–ª—è–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –∏–≥—Ä–æ–∫–æ–≤
          io.to(roomId).emit('player-left', {
            playerId: socket.id,
            players: room.players
          });
        }
        
        // –£–≤–µ–¥–æ–º–ª—è–µ–º –≤—Å–µ—Ö –æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –∫–æ–º–Ω–∞—Ç
        io.emit('rooms-updated');
        break;
      }
    }
  });
});

// –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
server.listen(PORT, HOST, () => {
  console.log(`üöÄ Socket Server listening on ${HOST}:${PORT}`);
  console.log(`üåê Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`üì± Process ID: ${process.pid}`);
  console.log(`üîå Socket.IO enabled for real-time rooms`);
});

// Graceful shutdown
process.once('SIGINT', () => {
  console.log('üõë Shutting down server...');
  server.close(() => {
    process.exit(0);
  });
});

process.once('SIGTERM', () => {
  console.log('üõë Shutting down server...');
  server.close(() => {
    process.exit(0);
  });
});

module.exports = server;
